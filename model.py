import torch
import torch.nn as nn
import torch.nn.functional as F


class MalConv(nn.Module):
    def __init__(self, window_size, num_embeddings=257, embedding_dim=8, num_channels=128):
        super(MalConv, self).__init__()
        self.embedding = nn.Embedding(num_embeddings, embedding_dim)
        self.conv1 = nn.Conv1d(embedding_dim, num_channels, kernel_size=window_size, stride=window_size)
        self.conv2 = nn.Conv1d(embedding_dim, num_channels, kernel_size=window_size, stride=window_size)
        self.pool = nn.AdaptiveMaxPool1d(1)
        self.fc1 = nn.Linear(num_channels, num_channels)
        self.fc2 = nn.Linear(num_channels, 2)

    def forward(self, x):
        # embedding layer
        out_embed = self.embedding(x)
        out_embed = out_embed.permute(0, 2, 1)

        # convolution layer
        out_conv1 = self.conv1(out_embed)
        out_conv2 = self.conv2(out_embed)
        out = out_conv1 * torch.sigmoid(out_conv2)

        # pooling layer
        out = self.pool(out).squeeze(2)

        # full connected layer
        out = F.relu(self.fc1(out))
        return self.fc2(out)
